{"version":3,"file":"index.mjs","sources":["../lib/kernel_rempio2f.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/9.3.0/lib/msun/src/k_rem_pio2.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n* ```\n*/\n\n/* eslint-disable array-element-newline */\n\n'use strict';\n\n// MODULES //\n\nimport floor from '@stdlib/math-base-special-floor';\nimport ldexp from '@stdlib/math-base-special-ldexp';\nimport zeros from '@stdlib/array-base-zeros';\n\n\n// VARIABLES //\n\n/*\n* Table of constants for `2/π` (`396` hex digits, `476` decimal).\n*\n* Integer array which contains the (`24*i`)-th to (`24*i+23`)-th bit of `2/π` after binary point. The corresponding floating value is\n*\n* ```tex\n* \\operatorname{ipio2}[i] \\cdot 2^{-24(i+1)}\n* ```\n*\n* This table must have at least `(e0-3)/24 + jk` terms. For single precision (`e0 <= 127`, `jk = 3`), this is `9`.\n*/\nvar IPIO2 = [\n\t0xA2F983, 0x6E4E44, 0x1529FC, 0x2757D1, 0xF534DD, 0xC0DB62,\n\t0x95993C, 0x439041, 0xFE5163\n];\n\n// Double precision array, obtained by cutting `π/2` into `24` bits chunks...\nvar PIO2 = [\n\t1.57079625129699707031e+00, // 0x3FF921FB, 0x40000000\n\t7.54978941586159635335e-08, // 0x3E74442D, 0x00000000\n\t5.39030252995776476554e-15, // 0x3CF84698, 0x80000000\n\t3.28200341580791294123e-22, // 0x3B78CC51, 0x60000000\n\t1.27065575308067607349e-29, // 0x39F01B83, 0x80000000\n\t1.22933308981111328932e-36, // 0x387A2520, 0x40000000\n\t2.73370053816464559624e-44, // 0x36E38222, 0x80000000\n\t2.16741683877804819444e-51  // 0x3569F31D, 0x00000000\n];\nvar TWO24 = 1.67772160000000000000e+07;  // 0x41700000, 0x00000000\nvar TWON24 = 5.96046447753906250000e-08; // 0x3E700000, 0x00000000\n\n// Arrays for storing temporary values (note that, in C, this is not thread safe):\nvar F = zeros( 20 );\nvar Q = zeros( 20 );\nvar FQ = zeros( 20 );\nvar IQ = zeros( 20 );\n\n\n// FUNCTIONS //\n\n/**\n* Performs the computation for `kernelRempio2f()`.\n*\n* @private\n* @param {PositiveNumber} x - input value\n* @param {(Array|TypedArray|Object)} y - output object for storing double precision numbers\n* @param {integer} jz - number of terms of `ipio2[]` used\n* @param {Array<integer>} q - array with integral values, representing the 24-bits chunk of the product of `x` and `2/π`\n* @param {integer} q0 - the corresponding exponent of `q[0]` (the exponent for `q[i]` would be `q0-24*i`)\n* @param {integer} jk - `jk+1` is the initial number of terms of `IPIO2[]` needed in the computation\n* @param {integer} jv - index for pointing to the suitable `ipio2[]` for the computation\n* @param {integer} jx - `nx - 1`\n* @param {Array<number>} f - `IPIO2[]` in floating point\n* @returns {number} last three binary digits of `N`\n*/\nfunction compute( x, y, jz, q, q0, jk, jv, jx, f ) {\n\tvar carry;\n\tvar fw;\n\tvar ih;\n\tvar jp;\n\tvar i;\n\tvar k;\n\tvar n;\n\tvar j;\n\tvar z;\n\n\t// `jp+1` is the number of terms in `PIO2[]` needed:\n\tjp = jk;\n\n\t// Distill `q[]` into `IQ[]` in reverse order...\n\tz = q[ jz ];\n\tj = jz;\n\tfor ( i = 0; j > 0; i++ ) {\n\t\tfw = ( TWON24 * z )|0;\n\t\tIQ[ i ] = ( z - (TWO24*fw) )|0;\n\t\tz = q[ j-1 ] + fw;\n\t\tj -= 1;\n\t}\n\t// Compute `n`...\n\tz = ldexp( z, q0 );\n\tz -= 8.0 * floor( z*0.125 ); // Trim off integer >= 8\n\tn = z|0;\n\tz -= n;\n\tih = 0;\n\tif ( q0 > 0 ) {\n\t\t// Need `IQ[jz-1]` to determine `n`...\n\t\ti = ( IQ[ jz-1 ] >> (24-q0) );\n\t\tn += i;\n\t\tIQ[ jz-1 ] -= ( i << (24-q0) );\n\t\tih = ( IQ[ jz-1 ] >> (23-q0) );\n\t}\n\telse if ( q0 === 0 ) {\n\t\tih = ( IQ[ jz-1 ] >> 23 );\n\t}\n\telse if ( z >= 0.5 ) {\n\t\tih = 2;\n\t}\n\t// Case: q > 0.5\n\tif ( ih > 0 ) {\n\t\tn += 1;\n\t\tcarry = 0;\n\n\t\t// Compute `1-q`:\n\t\tfor ( i = 0; i < jz; i++ ) {\n\t\t\tj = IQ[ i ];\n\t\t\tif ( carry === 0 ) {\n\t\t\t\tif ( j !== 0 ) {\n\t\t\t\t\tcarry = 1;\n\t\t\t\t\tIQ[ i ] = 0x1000000 - j;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIQ[ i ] = 0xffffff - j;\n\t\t\t}\n\t\t}\n\t\tif ( q0 > 0 ) {\n\t\t\t// Rare case: chance is 1 in 12...\n\t\t\tswitch ( q0 ) { // eslint-disable-line default-case\n\t\t\tcase 1:\n\t\t\t\tIQ[ jz-1 ] &= 0x7fffff;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tIQ[ jz-1 ] &= 0x3fffff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( ih === 2 ) {\n\t\t\tz = 1.0 - z;\n\t\t\tif ( carry !== 0 ) {\n\t\t\t\tz -= ldexp( 1.0, q0 );\n\t\t\t}\n\t\t}\n\t}\n\t// Check if re-computation is needed...\n\tif ( z === 0.0 ) {\n\t\tj = 0;\n\t\tfor ( i = jz-1; i >= jk; i-- ) {\n\t\t\tj |= IQ[ i ];\n\t\t}\n\t\tif ( j === 0 ) {\n\t\t\t// Need re-computation...\n\t\t\tfor ( k = 1; IQ[ jk-k ] === 0; k++ ) {\n\t\t\t\t// `k` is the number of terms needed...\n\t\t\t}\n\t\t\tfor ( i = jz+1; i <= jz+k; i++ ) {\n\t\t\t\t// Add `q[jz+1]` to `q[jz+k]`...\n\t\t\t\tf[ jx+i ] = IPIO2[ jv+i ];\n\t\t\t\tfw = 0.0;\n\t\t\t\tfor ( j = 0; j <= jx; j++ ) {\n\t\t\t\t\tfw += x[ j ] * f[ jx + (i-j) ];\n\t\t\t\t}\n\t\t\t\tq[ i ] = fw;\n\t\t\t}\n\t\t\tjz += k;\n\t\t\treturn compute( x, y, jz, q, q0, jk, jv, jx, f );\n\t\t}\n\t\t// Chop off zero terms...\n\t\tjz -= 1;\n\t\tq0 -= 24;\n\t\twhile ( IQ[ jz ] === 0 ) {\n\t\t\tjz -= 1;\n\t\t\tq0 -= 24;\n\t\t}\n\t} else {\n\t\t// Break `z` into 24-bit if necessary...\n\t\tz = ldexp( z, -q0 );\n\t\tif ( z >= TWO24 ) {\n\t\t\tfw = (TWON24*z)|0;\n\t\t\tIQ[ jz ] = ( z - (TWO24*fw) )|0;\n\t\t\tjz += 1;\n\t\t\tq0 += 24;\n\t\t\tIQ[ jz ] = fw;\n\t\t} else {\n\t\t\tIQ[ jz ] = z|0;\n\t\t}\n\t}\n\t// Convert integer \"bit\" chunk to floating-point value...\n\tfw = ldexp( 1.0, q0 );\n\tfor ( i = jz; i >= 0; i-- ) {\n\t\tq[ i ] = fw * IQ[i];\n\t\tfw *= TWON24;\n\t}\n\t// Compute `PIO2[0,...,jp]*q[jz,...,0]`...\n\tfor ( i = jz; i >= 0; i-- ) {\n\t\tfw = 0.0;\n\t\tfor ( k = 0; k <= jp && k <= jz-i; k++ ) {\n\t\t\tfw += PIO2[ k ] * q[ i+k ];\n\t\t}\n\t\tFQ[ jz-i ] = fw;\n\t}\n\t// Compress `FQ[]` into `y[]`...\n\tfw = 0.0;\n\tfor ( i = jz; i >= 0; i-- ) {\n\t\tfw += FQ[ i ];\n\t}\n\tif ( ih === 0 ) {\n\t\ty[ 0 ] = fw;\n\t} else {\n\t\ty[ 0 ] = -fw;\n\t}\n\treturn ( n & 7 );\n}\n\n\n// MAIN //\n\n/**\n* Returns the last three binary digits of `N` with `y = x - Nπ/2` so that `|y| < π/2` (single precision).\n*\n* ## Method\n*\n* -   The method is to compute the integer (mod 8) and fraction parts of (2/π) * x without doing the full multiplication. In general, we skip the part of the product that are known to be a huge integer (more accurately, = 0 mod 8 ). Thus the number of operations are independent of the exponent of the input.\n*\n* -   (2/π) is represented by an array of 24-bit integers in `ipio2[]`.\n*\n* -   Input parameters:\n*\n*     -   `x[]` The input value (must be positive) is broken into `nx` pieces of 24-bit integers in double precision format. `x[i]` will be the i-th 24 bit of x. The scaled exponent of `x[0]` is given in input parameter `e0` (i.e., `x[0]*2^e0` match x's up to 24 bits).\n*\n*         Example of breaking a double positive `z` into `x[0]+x[1]+x[2]`:\n*\n*         ```tex\n*         e0 = \\mathrm{ilogb}(z) - 23\n*         z = \\mathrm{scalbn}(z, -e0)\n*         ```\n*\n*         for `i = 0,1,2`\n*\n*         ```tex\n*         x[i] = \\lfloor z \\rfloor\n*         z = (z - x[i]) \\times 2^{24}\n*         ```\n*\n*     -   `y[]` output result in an array of double precision numbers.\n*\n*         The dimension of `y[]` is:\n*         24-bit precision     1\n*         53-bit precision     2\n*         64-bit precision     2\n*         113-bit precision    3\n*\n*         The actual value is the sum of them. Thus, for 113-bit precision, one may have to do something like:\n*\n*         ```tex\n*         \\mathrm{long\\ double} \\: t, w, r_{\\text{head}}, r_{\\text{tail}}; \\\\\n*         t &= (\\mathrm{long\\ double}) y[2] + (\\mathrm{long\\ double}) y[1]; \\\\\n*         w &= (\\mathrm{long\\ double}) y[0]; \\\\\n*         r_{\\text{head}} &= t + w; \\\\\n*         r_{\\text{tail}} &= w - (r_{\\text{head}} - t);\n*         ```\n*\n*     -   `e0` The exponent of `x[0]`. Must be <= 16360 or you need to expand the `ipio2` table.\n*\n*     -   `nx` dimension of `x[]`\n*\n*     -   `prec` an integer indicating the precision:\n*         0 24 bits (single)\n*         1 53 bits (double)\n*         2 64 bits (extended)\n*         3 113 bits (quad)\n*\n* -   External function:\n*\n*     -   double `scalbn()`, `floor()`;\n*\n* -   Here is the description of some local variables:\n*\n*     -   `jk` `jk+1` is the initial number of terms of `ipio2[]` needed in the computation. The minimum and recommended value for `jk` is 3,4,4,6 for single, double, extended, and quad. `jk+1` must be 2 larger than you might expect so that our recomputation test works. (Up to 24 bits in the integer part (the 24 bits of it that we compute) and 23 bits in the fraction part may be lost to cancellation before we recompute.)\n*\n*     -   `jz` local integer variable indicating the number of terms of `ipio2[]` used.\n*\n*     -   `jx` `nx - 1`\n*\n*     -   `jv` index for pointing to the suitable `ipio2[]` for the computation. In general, we want\n*\n*         ```tex\n*         \\frac{{2^{e0} \\cdot x[0] \\cdot \\mathrm{ipio2}[jv-1] \\cdot 2^{-24jv}}}{{8}}\n*         ```\n*\n*         to be an integer. Thus\n*\n*         ```tex\n*         e0 - 3 - 24 \\cdot jv \\geq 0 \\quad \\text{or} \\quad \\frac{{e0 - 3}}{{24}} \\geq jv\n*         ```\n*\n*         Hence\n*\n*         ```tex\n*         jv = \\max(0, \\frac{{e0 - 3}}{{24}})\n*         ```\n*\n*     -   `jp` `jp+1` is the number of terms in `PIo2[]` needed, `jp = jk`.\n*\n*     -   `q[]` double array with integral value, representing the 24-bits chunk of the product of `x` and `2/π`.\n*\n*     -   `q0` the corresponding exponent of `q[0]`. Note that the exponent for `q[i]` would be `q0-24*i`.\n*\n*     -   `PIo2[]` double precision array, obtained by cutting `π/2` into 24 bits chunks.\n*\n*     -   `f[]` `ipso2[]` in floating point\n*\n*     -   `iq[]` integer array by breaking up `q[]` in 24-bits chunk.\n*\n*     -   `fq[]` final product of `x*(2/π)` in `fq[0],..,fq[jk]`\n*\n*     -   `ih` integer. If >0 it indicates `q[]` is >= 0.5, hence it also indicates the _sign_ of the result.\n*\n* -   Constants:\n*\n*     -   The hexadecimal values are the intended ones for the following constants. The decimal values may be used, provided that the compiler will convert from decimal to binary accurately enough to produce the hexadecimal values shown.\n*\n* @private\n* @param {PositiveNumber} x - input value\n* @param {(Array|TypedArray|Object)} y - remainder element\n* @param {PositiveInteger} e0 - the exponent of `x[0]` (must be <= 127)\n* @param {PositiveInteger} nx - dimension of `x[]`\n* @returns {number} last three binary digits of `N`\n*/\nfunction kernelRempio2f( x, y, e0, nx ) {\n\tvar fw;\n\tvar jk;\n\tvar jv;\n\tvar jx;\n\tvar jz;\n\tvar q0;\n\tvar i;\n\tvar j;\n\tvar m;\n\n\t// Initialize `jk` for single-precision floating-point numbers:\n\tjk = 3;\n\n\t// Determine `jx`, `jv`, `q0` (note that `q0 < 3`):\n\tjx = nx - 1;\n\tjv = ( (e0 - 3) / 24 )|0;\n\tif ( jv < 0 ) {\n\t\tjv = 0;\n\t}\n\tq0 = e0 - (24 * (jv + 1));\n\n\t// Set up `F[0]` to `F[jx+jk]` where `F[jx+jk] = IPIO2[jv+jk]`:\n\tj = jv - jx;\n\tm = jx + jk;\n\tfor ( i = 0; i <= m; i++ ) {\n\t\tif ( j < 0 ) {\n\t\t\tF[ i ] = 0.0;\n\t\t} else {\n\t\t\tF[ i ] = IPIO2[ j ];\n\t\t}\n\t\tj += 1;\n\t}\n\t// Compute `Q[0],Q[1],...,Q[jk]`:\n\tfor ( i = 0; i <= jk; i++ ) {\n\t\tfw = 0.0;\n\t\tfor ( j = 0; j <= jx; j++ ) {\n\t\t\tfw += x[ j ] * F[ jx + (i-j) ];\n\t\t}\n\t\tQ[ i ] = fw;\n\t}\n\tjz = jk;\n\treturn compute( x, y, jz, Q, q0, jk, jv, jx, F );\n}\n\n\n// EXPORTS //\n\nexport default kernelRempio2f;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*\n*\n* ## Notice\n*\n* The following copyright and license were part of the original implementation available as part of [FreeBSD]{@link https://svnweb.freebsd.org/base/release/12.2.0/lib/msun/src/e_rem_pio2f.c}. The implementation follows the original, but has been modified for JavaScript.\n*\n* ```text\n* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n*\n* Developed at SunPro, a Sun Microsystems, Inc. business.\n* Permission to use, copy, modify, and distribute this\n* software is freely granted, provided that this notice\n* is preserved.\n*\n* Optimized by Bruce D. Evans.\n* ```\n*/\n\n'use strict';\n\n// MODULES //\n\nimport ABS_MASK from '@stdlib/constants-float32-abs-mask';\nimport EXPONENT_MASK from '@stdlib/constants-float32-exponent-mask';\nimport roundf from '@stdlib/math-base-special-roundf';\nimport fromWordf from '@stdlib/number-float32-base-from-word';\nimport toWordf from '@stdlib/number-float32-base-to-word';\nimport float64ToFloat32 from '@stdlib/number-float64-base-to-float32';\nimport rempio2Kernelf from './kernel_rempio2f.js';\n\n\n// VARIABLES //\n\n// 53 bits of 2/π:\nvar INVPIO2 = 6.36619772367581382433e-01; // 0x3FE45F30, 0x6DC9C883\n\n// First 25 bits of π/2:\nvar PIO2_1 = 1.57079631090164184570e+00;  // 0x3FF921FB, 0x50000000\n\n// PIO2_1T = π/2 - PIO2_1:\nvar PIO2_1T = 1.58932547735281966916e-08; // 0x3E5110b4, 0x611A6263\n\n// 2^28*π/2 = 421657428.2663131 => 0100000110111001001000011111101101010100010001000010110100011000 => high word => 0x4dc90fdb = 1102651899 => 01000001101110010010000111111011\nvar MEDIUM = 0x4dc90fdb|0; // asm type annotation\n\n// Arrays for storing temporary values:\nvar TX = [ 0.0 ];\nvar TY = [ 0.0 ];\n\n\n// MAIN //\n\n/**\n* Computes `x - nπ/2 = r` (single precision).\n*\n* ## Notes\n*\n* -   Returns `n` and stores the remainder `r` as `y[0]`.\n*\n* @param {number} x - input value\n* @param {(Array|TypedArray|Object)} y - remainder element\n* @returns {integer} factor of `π/2`\n*\n* @example\n* var y = [ 0.0 ];\n* var n = rempio2f( 128.0, y );\n* // returns 81\n*\n* var y1 = y[ 0 ];\n* // returns ~0.765\n*\n* @example\n* var y = [ 0.0 ];\n* var n = rempio2f( NaN, y );\n* // returns 0\n*\n* var y1 = y[ 0 ];\n* // returns NaN\n*/\nfunction rempio2f( x, y ) {\n\tvar e0;\n\tvar hx;\n\tvar ix;\n\tvar n;\n\tvar r;\n\tvar w;\n\tvar z;\n\n\tx = float64ToFloat32( x );\n\thx = toWordf( x );\n\tix = (hx & ABS_MASK)|0; // asm type annotation\n\n\t// Case: |x| ~< 2^28*π/2 (medium size)\n\tif ( ix < MEDIUM ) {\n\t\tn = roundf( float64ToFloat32( x * INVPIO2 ) );\n\t\tr = x - ( n * PIO2_1 );\n\t\tw = n * PIO2_1T;\n\t\ty[ 0 ] = r - w;\n\t\treturn n;\n\t}\n\t// Case: x is NaN or infinity\n\tif ( ix >= EXPONENT_MASK ) {\n\t\ty[ 0 ] = NaN;\n\t\treturn 0;\n\t}\n\t// Set z = scalbn(|x|, ilogb(|x|)-23)...\n\te0 = (ix >> 23) - 150; // `e0 = ilogb(|x|) - 23` => unbiased exponent minus 23\n\tz = fromWordf( ix - ((e0 << 23)|0) );\n\tTX[ 0 ] = z;\n\tn = rempio2Kernelf( TX, TY, e0, 1 );\n\tif ( hx < 0 ) {\n\t\ty[ 0 ] = -TY[ 0 ];\n\t\treturn -n;\n\t}\n\ty[ 0 ] = TY[ 0 ];\n\treturn n;\n}\n\n\n// EXPORTS //\n\nexport default rempio2f;\n"],"names":["IPIO2","PIO2","TWO24","TWON24","F","zeros","Q","FQ","IQ","compute","x","y","jz","q","q0","jk","jv","jx","f","carry","fw","ih","jp","i","k","n","j","z","ldexp","floor","kernelRempio2f","e0","nx","m","TX","TY","rempio2f","hx","ix","r","w","float64ToFloat32","toWordf","ABS_MASK","roundf","EXPONENT_MASK","NaN","fromWordf","rempio2Kernelf"],"mappings":"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"}